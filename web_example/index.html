<html>

<head>
    <style>
        .wrapper {
            /* Use flexbox */
            display: flex;
            height: 100%;
            max-width: 100%;
        }

        .box {
            /* Use box-sizing so that element's outerwidth will match width property */
            box-sizing: border-box;

            /* Allow box to grow and shrink, and ensure they are all equally sized */
            flex: 1 1 auto;
            min-width: 20%;
        }

        .handler {
            width: 15px;
            padding: 0;
            cursor: ew-resize;
            flex: 0 0 auto;
        }

        .handler::before {
            content: '';
            display: block;
            height: 100%;
            background: rgb(134, 134, 134);
        }
    </style>
</head>

<body>

    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    </head>

    <body style="margin:0; ">
        <div class="wrapper">
            <div class="box" ;>
                <canvas id="myCanvas" style=" height: 100%; "></canvas>
            </div>
            <div class="handler"></div>
            <div class="box" id="code_editor"></div>
        </div>
    </body>
    <script src="https://cdn.jsdelivr.net/npm/@monaco-editor/loader@1.3.2/lib/umd/monaco-loader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/assemblyscript@0.26.6/dist/web.js"></script>
    <script src="warp_core.js" type="module"></script>
    <script type="module">
        let initial_code =
            `@external("env", "set_color")
declare function set_color(r: u8, g: u8, b: u8, a: u8): void

@external("env", "draw_circle")
declare function draw_circle(x: f32, y: f32, radius: f32): void

let position: f32 = 0.0;
let direction: f32 = 1.0;

export function fixed_update(): void {
    position += 1.0 * direction;

    if (position > 400.0 || position < 0.0) {
        direction *= -1.0;
    }
}

export function pointer_down(x: u32, y: u32): void {
    direction *= -1.0;
}

export function draw(): void {
    set_color(0, 0, 255, 255);
    draw_circle(100, position, 100);
}
`;
        // Handle moving code
        {
            var handler = document.querySelector('.handler');
            var wrapper = handler.closest('.wrapper');
            var boxA = wrapper.querySelector('.box');
            var isHandlerDragging = false;

            document.addEventListener('mousedown', function (e) {
                // If mousedown event is fired from .handler, toggle flag to true
                if (e.target === handler) {
                    isHandlerDragging = true;
                }
            });

            document.addEventListener('mousemove', function (e) {
                // Don't do anything if dragging flag is false
                if (!isHandlerDragging) {
                    return false;
                }

                // Get offset
                var containerOffsetLeft = wrapper.offsetLeft;

                // Get x-coordinate of pointer relative to container
                var pointerRelativeXpos = e.clientX - containerOffsetLeft;

                // Arbitrary minimum width set on box A, otherwise its inner content will collapse to width of 0
                var boxAminWidth = 40;

                // Resize box A
                // * 8px is the left/right spacing between .handler and its inner pseudo-element
                // * Set flex-grow to 0 to prevent it from growing
                boxA.style.width = (Math.max(boxAminWidth, pointerRelativeXpos - 8)) + 'px';
                boxA.style.flexGrow = 0;
            });

            boxA.style.width = "50%";

            document.addEventListener('mouseup', function (e) {
                // Turn off dragging flag when user mouse is up
                isHandlerDragging = false;
            });
        }

        import asc from "assemblyscript/asc";
        let timeout_id;

        window.monaco_loader.init().then(async (monaco) => {

            monaco.languages.typescript.typescriptDefaults.addExtraLib(
                asc.definitionFiles.assembly,
                "assemblyscript/std/assembly/index.d.ts"
            );

            monaco.editor.defineTheme('customTheme', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'comment', foreground: 'ffa500', fontStyle: 'italic underline' },
                    { token: 'comment.js', foreground: '008800', fontStyle: 'bold' },
                    { token: 'comment.css', foreground: '0000ff' } // will inherit fontStyle from `comment` above
                ],
                colors: {
                }
            });

            let editor = monaco.editor.create(
                document.getElementById("code_editor"), {
                value: initial_code,
                language: 'typescript',
                automaticLayout: true,
                minimap: {
                    enabled: false
                },
                theme: "customTheme"
            });

            editor.getModel().onDidChangeContent((event) => {

                if (timeout_id) {
                    clearTimeout(timeout_id);
                }
                // I'd prefer run this in a worker instead, but it seems ASC's web compiler isn't setup for that.
                timeout_id = setTimeout(() => {
                    console.log("Compiling!");
                    compile_assemblyscript(editor.getValue());
                }, 300);
            });

            // compile_assemblyscript(editor.getValue());
        });



        function compile_assemblyscript(source) {
            // This code is adapted from here: 
            // https://github.com/AssemblyScript/website/blob/main/src/.vuepress/public/editor.html
            const tsModule = 'module.ts'
            const wasmModule = 'module.wasm'

            const stdout = asc.createMemoryStream()
            const sources = {
                'module.ts': source
            }

            const outputs = {}
            const config = {
                stdout,
                stderr: stdout,
                readFile: name => Object.prototype.hasOwnProperty.call(sources, name) ? sources[name] : null,
                writeFile: (name, contents) => { outputs[name] = contents },
                listFiles: () => []
            }
            const options = [
                tsModule,
                '--outFile', wasmModule,
                '--bindings', 'raw',
                // ...getCompilerOptions()
            ]
            asc.main(options, config).then(({ error, stdout }) => {
                let output = stdout.toString().trim()
                if (output.length) {
                    output = ';; ' + output.replace(/\n/g, '\n;; ') + '\n'
                }
                output = ';; INFO asc ' + options.join(' ') + '\n' + output
                if (error) {
                    console.log("Compilation error: ", error);
                    // binaryEditor.setValue(output + `(module\n ;; FAILURE ${error.message}\n)\n`)
                } else {

                    console.log("OUTPUTS: ", outputs);
                    var module_wasm = outputs[wasmModule]
                    window.warpcore.set_program(module_wasm);

                    // module_js = outputs[jsModule]
                    // binaryEditor.setValue(output + module_wast)
                }
                var didCompile = true
                // if (cb) cb(error)
            })
        };


        import { WarpCore, RoomState } from "./warp_core.js";

        async function run() {
            const image = new Image(60, 45); // Using optional size for image
            image.src = "kenney_pixelplatformer/Tilemap/characters.png";

            var canvas = document.getElementById("myCanvas");
            var context = canvas.getContext("2d");

            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            window.onresize = function (event) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
            }
            context.fillStyle = "blue";
            context.fillRect(0, 0, canvas.width, canvas.height);

            let wasm_binary = await fetch("example_script.wasm").then(response => response.arrayBuffer());
            const decoder = new TextDecoder();

            let imports = {
                env: {
                    external_log: function (pointer, length) {
                        let memory = warpcore.get_memory();
                        console.log("EXTERNAL LOG CALLED");

                        const message_data = new Uint8Array(memory.buffer, pointer, length);
                        const decoded_string = decoder.decode(new Uint8Array(message_data));
                        console.log(decoded_string);

                    },
                    external_error: function (pointer, length) {
                        console.log("EXTERNAL ERROR CALLED");

                        // const message_data = new Uint8Array(memory.buffer, pointer, length);
                        // const decoded_string = decoder.decode(new Uint8Array(message_data));
                        // console.error(decoded_string);
                    },
                    set_color: function (r, g, b, a) {
                        context.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                    },
                    draw_rect: function (r, g, b, a, x, y, w, h) {
                        context.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                        context.fillStyle =
                            context.fillRect(x, y, w, h);
                    },
                    draw_circle: function (x, y, radius) {
                        context.beginPath();
                        context.arc(x, y, radius, 0, 2 * Math.PI);
                        context.fill();
                    },
                    draw_image: function (sx, sy, sw, sh, x, y, w, h) {
                        context.drawImage(image, sx, sy, 25, 25, x, y, w, h);
                    }
                }
            };

            let player_id = 0;
            let current_animation_time = Date.now();
            let fixed_update_rate = 1000 / 60;
            let start_time = 0;
            let paused = false;

            async function animation() {

                if (!paused) {
                    let time_now = Date.now();
                    let diff = time_now - current_animation_time;

                    context.clearRect(0, 0, context.canvas.width, context.canvas.height);

                    await warpcore.progress_time(diff);
                    await warpcore.call_and_revert("draw", []);

                    current_animation_time = time_now;
                }
                window.requestAnimationFrame(animation);
            }

            let warpcore = await WarpCore.setup(wasm_binary, imports, fixed_update_rate, (state) => {
                if (state === RoomState.Connected) {
                    start_time = Date.now();

                    //  (async () => {
                    //      await warpcore.progress_time(100);
                    //      await warpcore.rewind_time(0);
                    //  })();
                    animation();
                }
            });
            window.warpcore = warpcore;

            document.onkeyup = async (event) => {

                /*
                if (event.code == "KeyP") {
                    window.warpcore.set_program(wasm_binary);
                }
                */

            };

            canvas.onpointerdown = async (event) => {
                if (!paused) {
                    await warpcore.call("pointer_down", [event.clientX, event.clientY]);
                    // await warpcore.call("add_ball", [player_id, event.clientX, event.clientY, Math.random(), Math.random() * 255, Math.random() * 255, Math.random() * 255]);
                }
            };
        };
        run();

    </script>

</body>

</html>