<html>

<body>

    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    </head>

    <body style="margin:0; overflow-y: hidden;overflow-x: hidden; touch-action: none;">
        <canvas id="myCanvas" style="width:100vw; height: 100vh; "></canvas>
    </body>
    <script src="warp_core.js" type="module"></script>
    <script type="module">
        import { WarpCore, RoomState } from "./warp_core.js";

        async function run() {
            const image = new Image(60, 45); // Using optional size for image
            image.src = "kenney_pixelplatformer/Tilemap/characters.png";

            var canvas = document.getElementById("myCanvas");
            var context = canvas.getContext("2d");

            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            window.onresize = function (event) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
            }
            context.fillStyle = "blue";
            context.fillRect(0, 0, canvas.width, canvas.height);

            let wasm_binary = await fetch("example_script.wasm").then(response => response.arrayBuffer());
            const decoder = new TextDecoder();

            let imports = {
                env: {
                    external_log: function (pointer, length) {
                        let memory = warpcore.get_memory();
                        console.log("EXTERNAL LOG CALLED");

                        const message_data = new Uint8Array(memory.buffer, pointer, length);
                        const decoded_string = decoder.decode(new Uint8Array(message_data));
                        console.log(decoded_string);

                    },
                    external_error: function (pointer, length) {
                        console.log("EXTERNAL ERROR CALLED");

                        // const message_data = new Uint8Array(memory.buffer, pointer, length);
                        // const decoded_string = decoder.decode(new Uint8Array(message_data));
                        // console.error(decoded_string);
                    },
                    draw_rect: function (r, g, b, a, x, y, w, h) {
                        context.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                        context.fillStyle =
                            context.fillRect(x, y, w, h);
                    },
                    draw_circle: function (r, g, b, a, x, y, radius) {
                        context.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                        context.beginPath();
                        context.arc(x, y, radius, 0, 2 * Math.PI);
                        context.fill();
                    },
                    draw_image: function (sx, sy, sw, sh, x, y, w, h) {
                        context.drawImage(image, sx, sy, 25, 25, x, y, w, h);
                    }
                }
            };

            let player_id = 0;
            let current_animation_time = Date.now();
            let fixed_update_rate = 1000 / 60;
            let start_time = 0;
            let paused = false;

            async function animation() {

                if (!paused) {
                    let time_now = Date.now();
                    let diff = time_now - current_animation_time;

                    context.clearRect(0, 0, context.canvas.width, context.canvas.height);

                    await warpcore.progress_time(diff);
                    await warpcore.call_and_revert("draw", []);

                    current_animation_time = time_now;
                }
                window.requestAnimationFrame(animation);
            }

            let warpcore = await WarpCore.setup(wasm_binary, imports, fixed_update_rate, (state) => {
                if (state === RoomState.Connected) {
                    start_time = Date.now();

                    //  (async () => {
                    //      await warpcore.progress_time(100);
                    //      await warpcore.rewind_time(0);
                    //  })();
                    animation();
                }
            });

            document.onkeyup = async (event) => {

                if (event.code == "KeyP") {
                    paused = !paused;
                }

            };

            canvas.onpointerdown = async (event) => {
                if (!paused) {
                    await warpcore.call("add_ball", [player_id, event.clientX, event.clientY, Math.random(), Math.random() * 255, Math.random() * 255, Math.random() * 255]);
                }
            };
        };
        run();
    </script>

</body>

</html>