{
  "version": 3,
  "sources": ["../src/room.ts", "../src/offline_tangle.ts", "../src/message_encoding.ts", "../src/online_tangle.ts"],
  "sourcesContent": ["export interface RoomConfiguration {\n    name?: string\n    server_url?: string\n    on_state_change?: (room_state: RoomState) => void;\n    on_peer_joined?: (peer_id: PeerId) => void;\n    on_peer_left?: (peer_id: PeerId, time: number) => void;\n    on_message?: (peer_id: PeerId, message: Uint8Array) => void;\n}\n\nexport type PeerId = number;\n\nexport enum RoomState {\n    Joining,\n    Connected,\n    Disconnected\n}\n\ntype Peer = {\n    id: PeerId,\n    connection: RTCPeerConnection,\n    data_channel: RTCDataChannel,\n    ready: boolean,\n    latest_message_data: Uint8Array\n    latest_message_offset: number,\n}\n\nenum MessageType {\n    MultiPartStart = 1,\n    MultiPartContinuation = 2,\n    SinglePart = 3,\n}\n\nconst MAX_MESSAGE_SIZE = 16_000;\n\n// TODO: This is generated by ChatGPT. Audit it.\nfunction compute_id_from_ip(ipAddress: string): number {\n    let uniqueNumber = 0;\n    const parts = ipAddress.split(':');\n    const ip = parts[0].split('.');\n    const port = parseInt(parts[1], 10);\n\n    for (let i = 0; i < 4; i++) {\n        uniqueNumber += parseInt(ip[i], 10) * Math.pow(256, 3 - i);\n    }\n    uniqueNumber += port;\n\n    return uniqueNumber;\n}\n\nexport class Room {\n    private _peers_to_join: Set<PeerId> = new Set();\n    private _current_state: RoomState = RoomState.Disconnected;\n    private _peers: Map<PeerId, Peer> = new Map();\n    private _configuration: RoomConfiguration = {};\n    private _current_room_name: String = \"\";\n    private outgoing_data_chunk = new Uint8Array(MAX_MESSAGE_SIZE + 5);\n    private _artificial_delay = 0;\n    my_id: number = 0;\n\n    static async setup(_configuration: RoomConfiguration): Promise<Room> {\n        let room = new Room();\n        await room._setup_inner(_configuration);\n        return room;\n    }\n\n    private message_peer_inner(peer: Peer, data: Uint8Array) {\n        if (!(peer.data_channel.readyState === \"open\")) {\n            // TODO: This could result in desyncs if this happens.\n            return;\n        }\n        // TODO: Verify this\n        // If the message is too large fragment it. \n        // TODO: If there's not space in the outgoing channel push messages to an outgoing buffer.\n\n        let total_length = data.byteLength;\n\n        if (total_length > MAX_MESSAGE_SIZE) {\n            this.outgoing_data_chunk[0] = MessageType.MultiPartStart;\n            new DataView(this.outgoing_data_chunk.buffer).setUint32(1, total_length);\n\n            this.outgoing_data_chunk.set(data.subarray(0, MAX_MESSAGE_SIZE), 5);\n            peer.data_channel.send(this.outgoing_data_chunk);\n\n            let data_offset = data.subarray(MAX_MESSAGE_SIZE);\n\n            while (data_offset.byteLength > 0) {\n                length = Math.min(data_offset.byteLength, MAX_MESSAGE_SIZE);\n                this.outgoing_data_chunk[0] = MessageType.MultiPartContinuation;\n                this.outgoing_data_chunk.set(data_offset.subarray(0, length), 1);\n                data_offset = data_offset.subarray(length);\n\n                peer.data_channel.send(this.outgoing_data_chunk.subarray(0, length + 1));\n\n            }\n        } else {\n            this.outgoing_data_chunk[0] = MessageType.SinglePart;\n            this.outgoing_data_chunk.set(data, 1);\n\n            peer.data_channel.send(this.outgoing_data_chunk.subarray(0, data.byteLength + 1));\n        }\n\n    }\n\n    send_message(data: Uint8Array, peer_id?: PeerId) {\n        if (peer_id) {\n            let peer = this._peers.get(peer_id)!;\n            this.message_peer_inner(peer, data);\n        } else {\n            for (let [_, peer] of this._peers) {\n                if (!peer.ready) {\n                    continue;\n                }\n\n                this.message_peer_inner(peer, data);\n            }\n        }\n    }\n\n    get_lowest_latency_peer(): PeerId | undefined {\n        // TODO: Implement this.\n        return this._peers.entries().next().value?.[0];\n    }\n\n    private async _setup_inner(room__configuration: RoomConfiguration) {\n        onhashchange = (event) => {\n            if (this._current_room_name != document.location.hash.substring(1)) {\n                location.reload();\n                this._current_room_name = document.location.hash.substring(1);\n            }\n        };\n\n        this._configuration = room__configuration;\n        this._configuration.name ??= \"\";\n        this._configuration.server_url ??= \"tangle-server.fly.dev\";\n\n        const server_socket = new WebSocket(\"wss://\" + this._configuration.server_url);\n        server_socket.onopen = () => {\n            console.log(\"[room] Connection established with server\");\n            console.log(\"[room] Requesting to join room: \", this._configuration.name);\n            server_socket.send(JSON.stringify({ 'join_room': document.location.hash.substring(1) }));\n        };\n\n        server_socket.onmessage = async (event) => {\n            const last_index = event.data.lastIndexOf('}');\n            const json = event.data.substring(0, last_index + 1);\n\n            const message = JSON.parse(json);\n            // peer_id is appended by the server to the end of incoming messages.\n            let peer_ip = event.data.substring(last_index + 1).trim();\n            let peer_id = compute_id_from_ip(peer_ip);\n\n            if (message.room_name) {\n                // Received when joining a room for the first time.\n                console.log(\"[room] Entering room: \", message.room_name);\n\n                this._current_state = RoomState.Joining;\n\n                let peers_to_join_ids = message.peers.map(compute_id_from_ip);\n                this._peers_to_join = new Set(peers_to_join_ids);\n\n                this._configuration.on_state_change?.(this._current_state);\n\n                // If we've already connected to a peer then remove it from _peers_to_join.\n                for (const [key, value] of this._peers) {\n                    this._peers_to_join.delete(key);\n                }\n                this.check_if_joined();\n\n                // TODO: Make this messing with the URL an optional thing.\n                document.location =\n                    document.location.origin.toString() +\n                    '#' + message.room_name;\n                this._current_room_name = message.room_name;\n                console.log(\"MY IP: \", message.your_ip);\n                this.my_id = compute_id_from_ip(message.your_ip);\n            } else if (message.join_room) {\n                console.log(\"[room] Peer joining room: \", peer_id);\n                this.make_rtc_peer_connection(peer_ip, peer_id, server_socket);\n            } else if (message.offer) {\n                let peer_connection = this.make_rtc_peer_connection(peer_ip, peer_id, server_socket);\n                await peer_connection.setRemoteDescription(new RTCSessionDescription(message.offer));\n                const answer = await peer_connection.createAnswer();\n                await peer_connection.setLocalDescription(answer);\n                server_socket.send(JSON.stringify({ 'answer': answer, 'destination': peer_ip }));\n            } else if (message.answer) {\n                const remoteDesc = new RTCSessionDescription(message.answer);\n                await this._peers.get(peer_id)?.connection.setRemoteDescription(remoteDesc);\n            } else if (message.new_ice_candidate) {\n                try {\n                    await this._peers.get(peer_id)?.connection.addIceCandidate(message.new_ice_candidate);\n                } catch (e) {\n                    console.error(\"[room] Error adding received ice candidate\", e);\n                }\n            } else if (message.disconnected_peer_id) {\n                let disconnected_peer_id = compute_id_from_ip(message.disconnected_peer_id);\n                console.log(\"[room] Peer left: \", disconnected_peer_id);\n                this.remove_peer(disconnected_peer_id, message.time);\n                this._peers_to_join.delete(disconnected_peer_id);\n                this.check_if_joined();\n            }\n        };\n\n        server_socket.onclose = (event) => {\n            // Disconnecting from the WebSocket is considered a full disconnect from the room.\n\n            // TODO: On disconnected callback\n            this._current_state = RoomState.Disconnected;\n            this._peers_to_join.clear();\n            this._peers.clear();\n\n            if (event.wasClean) {\n                console.log(`[room] Server connection closed cleanly, code=${event.code} reason=${event.reason}`);\n            } else {\n                console.log('[room] Connection died');\n            }\n\n            this._configuration.on_state_change?.(this._current_state);\n        };\n\n        server_socket.onerror = function (error) {\n            console.log(`[room] Server socket error ${error}`);\n        };\n    }\n\n    private check_if_joined() {\n        if (this._current_state == RoomState.Joining && this._peers_to_join.size == 0) {\n            this._current_state = RoomState.Connected;\n            this._configuration.on_state_change?.(this._current_state);\n        }\n    }\n\n    private make_rtc_peer_connection(peer_ip: string, peer_id: PeerId, server_socket: WebSocket): RTCPeerConnection {\n        const ICE_SERVERS = [\n            { urls: \"stun:stun1.l.google.com:19302\" },\n        ];\n        const peer_connection = new RTCPeerConnection({ 'iceServers': ICE_SERVERS });\n\n        // TODO: If this is swapped to a more unreliable UDP-like protocol then ordered and maxRetransmits should be set to false and 0.\n        //\n        // maxRetransmits: null is meant to be the default but explicitly setting it seems to trigger a Chrome\n        // bug where some packets are dropped.\n        // TODO: Report this bug.\n        const data_channel = peer_connection.createDataChannel(\"sendChannel\", { negotiated: true, id: 2, ordered: true });\n        data_channel.binaryType = \"arraybuffer\";\n\n        peer_connection.onicecandidate = event => {\n            console.log(\"[room] New ice candidate: \", event.candidate);\n            if (event.candidate) {\n                console.log(JSON.stringify({ 'new_ice_candidate': event.candidate, 'destination': peer_ip }));\n                server_socket.send(JSON.stringify({ 'new_ice_candidate': event.candidate, 'destination': peer_ip }));\n            }\n        };\n\n        peer_connection.onicecandidateerror = event => {\n            console.log(\"[room] Ice candidate error: \", event);\n        };\n\n        peer_connection.onnegotiationneeded = async (event) => {\n            console.log(\"[room] Negotiation needed\");\n            const offer = await peer_connection.createOffer();\n            await peer_connection.setLocalDescription(offer);\n            server_socket.send(JSON.stringify({ 'offer': offer, 'destination': peer_ip }));\n        };\n\n        peer_connection.onsignalingstatechange = (event) => {\n            console.log(\"[room] Signaling state changed: \", peer_connection.signalingState)\n        };\n\n        peer_connection.onconnectionstatechange = (event) => {\n            console.log(\"[room] Connection state changed: \", peer_connection.connectionState)\n        };\n\n        peer_connection.ondatachannel = (event) => {\n            let data_channel = event.channel;\n\n        };\n\n        data_channel.onopen = event => {\n            this._peers_to_join.delete(peer_id);\n\n            this._peers.get(peer_id)!.ready = true;\n            this._configuration.on_peer_joined?.(peer_id);\n            this.check_if_joined();\n\n            /*\n            peer_connection.getStats().then((stats) => {\n    \n                console.log(\"[room] DataChannel stats: \");\n                console.log(stats);\n                stats.forEach((report) => {\n                    //  console.log(\"REPORT: %s \", report.type, report);\n                    if (report.type === \"candidate-pair\") {\n                        console.log(\"[room] Round trip seconds to _peers: %s : %s\", peer_id, report.currentRoundTripTime);\n                    }\n                });\n    \n                this._peers_to_join.delete(peer_id);\n    \n                this._peers.get(peer_id)!.ready = true;\n                this._configuration.on_peer_joined?.(peer_id);\n                this.check_if_joined();\n            });\n            */\n        }\n\n        data_channel.onmessage = (event) => {\n            // First check that this peer hasn't been officially disconnected.\n            if (this._peers.get(peer_id)) {\n                if (event.data.byteLength > 0) {\n                    // Defragment the message\n                    let message_data = new Uint8Array(event.data);\n                    switch (message_data[0]) {\n                        case MessageType.SinglePart: {\n                            // Call the user provided callback\n                            setTimeout(() => {\n                                this._configuration.on_message?.(peer_id, message_data.subarray(1));\n                            }, this._artificial_delay);\n                            break;\n                        }\n                        case MessageType.MultiPartStart: {\n                            let data = new DataView(message_data.buffer, 1);\n                            let length = data.getUint32(0);\n\n                            let peer = this._peers.get(peer_id)!;\n                            peer.latest_message_data = new Uint8Array(length);\n                            this.multipart_data_received(peer, message_data.subarray(5));\n                            break;\n                        }\n                        case MessageType.MultiPartContinuation: {\n                            let peer = this._peers.get(peer_id)!;\n                            this.multipart_data_received(peer, message_data.subarray(1));\n                        }\n                    }\n                }\n            } else {\n                console.error(\"DISCARDING MESSAGE FROM PEER: \", event.data);\n            }\n        }\n\n        this._peers.set(peer_id, { id: peer_id, connection: peer_connection, data_channel, ready: false, latest_message_data: new Uint8Array(0), latest_message_offset: 0 });\n        return peer_connection;\n    }\n\n    private multipart_data_received(peer: Peer, data: Uint8Array) {\n        peer.latest_message_data.set(data, peer.latest_message_offset);\n        peer.latest_message_offset += data.byteLength;\n\n        if (peer.latest_message_offset == peer.latest_message_data.length) {\n            let data = peer.latest_message_data;\n\n            // TODO: This introduces a potential one-frame delay on incoming events.\n            // Message received\n            setTimeout(() => {\n                this._configuration.on_message?.(peer.id, data);\n            }, this._artificial_delay);\n            peer.latest_message_offset = 0;\n            peer.latest_message_data = new Uint8Array(0);\n        }\n    }\n\n    private remove_peer(peer_id: PeerId, time: number) {\n        let peer = this._peers.get(peer_id);\n\n        if (peer) {\n            peer.connection.close();\n            this._peers.delete(peer_id);\n            this._configuration.on_peer_left?.(peer_id, time);\n        }\n    }\n}\n\n", "const WASM_PAGE_SIZE = 65536;\n\nenum WasmActionType {\n    Store,\n    Grow,\n    GlobalSet\n}\n\ntype Store = {\n    action_type: WasmActionType.Store,\n    location: number,\n    old_value: Uint8Array\n    // hash_before: Uint8Array\n};\n\ntype Grow = {\n    action_type: WasmActionType.Grow,\n    old_page_count: number,\n    // hash_before: Uint8Array\n};\n\ntype GlobalSet = {\n    action_type: WasmActionType.GlobalSet,\n    global_id: string,\n    old_value: any,\n};\n\ntype WasmSnapShot = {\n    memory: Uint8Array,\n    // The index in the exports and the value to set the export to\n    globals: Array<[number, number]>,\n}\n\ntype WasmAction = Store | Grow | GlobalSet;\n\nexport enum RollbackStrategy {\n    WasmSnapshots,\n    Granular,\n}\n\nexport type TimeStamp = {\n    time: number,\n    player_id: number,\n};\n\nexport function time_stamp_compare(a: TimeStamp, b: TimeStamp): number {\n    let v = Math.sign(a.time - b.time);\n    if (v != 0) {\n        return v;\n    }\n\n    v = Math.sign(a.player_id - b.player_id);\n    if (v != 0) {\n        return v;\n    }\n\n    return 0;\n}\n\nexport type FunctionCall = {\n    hash_after?: Uint8Array,\n    name: string,\n    args: Array<number>,\n    actions_caused: number,\n    time_stamp: TimeStamp,\n    // Used if the 'WasmSnapshot' RollBackStrategy is used.\n    wasm_snapshot_before?: WasmSnapShot\n};\n\ntype UpcomingFunctionCall = {\n    function_name: string,\n    args: Array<number>,\n    time_stamp: TimeStamp,\n}\n\nexport class OfflineTangle {\n    /// The Wasm code used by Tangle itself.\n    static _tangle_wasm?: WebAssembly.WebAssemblyInstantiatedSource;\n    /// The user Wasm that Tangle is syncing \n    wasm_instance?: WebAssembly.WebAssemblyInstantiatedSource = undefined;\n    current_time: number = 0;\n    private _recurring_call_interval: number = 0;\n    recurring_call_time: number = 0;\n    private _recurring_call_name?: string = \"fixed_update\";\n    private _actions: Array<WasmAction> = [];\n    function_calls: Array<FunctionCall> = [];\n    private _imports: WebAssembly.Imports = {};\n\n    private _rollback_strategy: RollbackStrategy = RollbackStrategy.Granular;\n    private _upcoming_function_calls: Array<UpcomingFunctionCall> = new Array();\n\n    // Optionally track hashes after each function call\n    hash_tracking: boolean = true;\n\n    static async setup(wasm_binary: Uint8Array, imports: WebAssembly.Imports, recurring_call_interval: number, rollback_strategy?: RollbackStrategy): Promise<OfflineTangle> {\n        let decoder = new TextDecoder();\n\n        let imports_tangle_wasm: WebAssembly.Imports = {\n            env: {\n                external_log: function (pointer: number, length: number) {\n                    let memory = OfflineTangle._tangle_wasm?.instance.exports.memory as WebAssembly.Memory;\n                    const message_data = new Uint8Array(memory.buffer, pointer, length);\n                    const decoded_string = decoder.decode(new Uint8Array(message_data));\n                    console.log(decoded_string);\n                },\n                external_error: function (pointer: number, length: number) {\n                    let memory = OfflineTangle._tangle_wasm?.instance.exports.memory as WebAssembly.Memory;\n                    const message_data = new Uint8Array(memory.buffer, pointer, length);\n                    const decoded_string = decoder.decode(new Uint8Array(message_data));\n                    console.error(decoded_string);\n                }\n            }\n        };\n\n        OfflineTangle._tangle_wasm ??= await WebAssembly.instantiateStreaming(fetch(\"rust_utilities.wasm\"), imports_tangle_wasm);\n\n        if (!rollback_strategy) {\n            // TODO: Check initial memory size and choose a rollback strategy based on that.\n            rollback_strategy = RollbackStrategy.WasmSnapshots;\n        }\n\n        let tangle = new OfflineTangle();\n        tangle._rollback_strategy = rollback_strategy;\n        tangle._recurring_call_interval = recurring_call_interval;\n        tangle._imports = imports;\n\n        wasm_binary = await process_binary(wasm_binary, true, rollback_strategy == RollbackStrategy.Granular);\n\n        if (rollback_strategy == RollbackStrategy.Granular) {\n\n            tangle._imports.wasm_guardian = {\n                on_store: (location: number, size: number) => {\n                    // console.log(\"HASH BEFORE STORE: \", tangle.hash());\n\n                    //  console.log(\"on_store called: \", location, size);\n                    if ((location + size) > (tangle.wasm_instance!.instance.exports.memory as WebAssembly.Memory).buffer.byteLength) {\n                        console.log(\"OUT OF BOUNDS MEMORY SIZE IN PAGES: \", (location + size) / WASM_PAGE_SIZE);\n                        console.error(\"MEMORY OUT OF BOUNDS!: \", location + size);\n                    } else {\n                        let memory = tangle.wasm_instance!.instance.exports.memory as WebAssembly.Memory;\n                        let old_value = new Uint8Array(new Uint8Array(memory.buffer, location, size));\n                        tangle._actions.push({ action_type: WasmActionType.Store, location: location, old_value: old_value, /* hash_before: tangle.hash() */ });\n                    }\n                },\n                on_grow: (pages: number) => {\n                    console.log(\"on_grow called: \", pages);\n                    let memory = tangle.wasm_instance!.instance.exports.memory as WebAssembly.Memory;\n                    console.log(\"NEW MEMORY SIZE IN PAGES: \", (memory.buffer.byteLength / WASM_PAGE_SIZE) + 1);\n\n                    tangle._actions.push({ action_type: WasmActionType.Grow, old_page_count: memory.buffer.byteLength / WASM_PAGE_SIZE, /* hash_before: tangle.hash() */ });\n                },\n                on_global_set: (id: number) => {\n                    //  console.log(\"on_global_set called: \", id);\n                    let global_id = \"wg_global_\" + id;\n                    tangle._actions.push({ action_type: WasmActionType.GlobalSet, global_id: global_id, old_value: tangle.wasm_instance?.instance.exports[global_id] });\n                },\n            };\n        }\n        let wasm_instance = await WebAssembly.instantiate(wasm_binary, tangle._imports);\n\n        console.log(\"HEAP SIZE: \", (wasm_instance.instance.exports.memory as WebAssembly.Memory).buffer.byteLength);\n        tangle.wasm_instance = wasm_instance;\n\n        return tangle;\n    }\n\n    async assign_memory(new_memory_data: Uint8Array) {\n        let mem = this.wasm_instance?.instance.exports.memory as WebAssembly.Memory;\n        let page_diff = (new_memory_data.byteLength - mem.buffer.byteLength) / WASM_PAGE_SIZE;\n\n        // The only way to \"shrink\" a Wasm instance is to construct an entirely new \n        // one with a new memory.\n        // Hopefully Wasm gets a better way to shrink modules in the future.\n\n        if (page_diff < 0) {\n            let old_instance = this.wasm_instance!.instance;\n            this.wasm_instance!.instance = await WebAssembly.instantiate(this.wasm_instance!.module, this._imports);\n            page_diff = (new_memory_data.byteLength - (this.wasm_instance?.instance.exports.memory as WebAssembly.Memory).buffer.byteLength) / WASM_PAGE_SIZE;\n\n            // Copy over all globals during the resize.\n            for (const [key, v] of Object.entries(old_instance.exports)) {\n                if (key.slice(0, 3) == \"wg_\") {\n                    (this.wasm_instance!.instance.exports[key] as WebAssembly.Global).value = v;\n                }\n            }\n\n            // Todo: Copy Wasm tables as well.\n        }\n\n        let old_memory = this.wasm_instance?.instance.exports.memory as WebAssembly.Memory;\n        if (page_diff > 0) {\n            old_memory.grow(page_diff);\n        }\n        new Uint8Array(old_memory.buffer).set(new_memory_data);\n    }\n\n    async reset_with_new_program(wasm_binary: Uint8Array, current_time: number) {\n        console.log(\"RESETTING WITH NEW PROGRAM-----------\");\n\n        wasm_binary = await process_binary(wasm_binary, true, this._rollback_strategy == RollbackStrategy.Granular);\n\n        this.wasm_instance = await WebAssembly.instantiate(wasm_binary, this._imports);\n        console.log(\"BINARY HASH: \", this.hash_data(wasm_binary));\n\n        this._actions = [];\n        this.function_calls = [];\n\n        // TODO: It might be better to not reset time here.\n        this.current_time = current_time;\n        this.recurring_call_time = 0;\n    }\n\n    /// Restarts the Tangle with a new memory.\n    async reset_with_wasm_memory(new_memory_data: Uint8Array, new_globals_data: Map<number, number>, current_time: number, recurring_call_time: number) {\n        this.assign_memory(new_memory_data);\n\n        let exports = this.wasm_instance!.instance.exports;\n\n        for (const [key, value] of new_globals_data) {\n            (exports[`wg_global_${key}`] as WebAssembly.Global).value = value;\n        }\n\n        this._actions = [];\n        this.function_calls = [];\n\n        this.current_time = current_time;\n        this.recurring_call_time = recurring_call_time;\n    }\n\n    remove_history_before(time: number) {\n        // TODO: More carefully audit this function for correctness.\n\n        let to_remove = 0;\n\n        let i = 0;\n        for (i = 0; i < this.function_calls.length; i++) {\n            let f = this.function_calls[i];\n            if (f.time_stamp.time < time) {\n                to_remove += f.actions_caused;\n            } else {\n                break;\n            }\n        }\n\n        // Remove all actions that occurred before this.\n        this._actions.splice(0, to_remove);\n\n        // Always leave one function call for debugging purposes.\n        this.function_calls.splice(0, i - 1);\n        //console.log(\"ACTIONS: \", this._actions);\n    }\n\n\n    private async _revert_actions(actions_to_remove: number) {\n        let memory = this.wasm_instance?.instance.exports.memory as WebAssembly.Memory;\n\n        let to_rollback = this._actions.splice(this._actions.length - actions_to_remove, actions_to_remove);\n        for (let i = to_rollback.length - 1; i >= 0; i--) {\n            let action = to_rollback[i];\n            switch (action.action_type) {\n                case WasmActionType.Store: {\n                    let destination = new Uint8Array(memory.buffer, action.location, action.old_value.byteLength);\n                    destination.set(action.old_value);\n\n\n                    // let hash = this.hash();\n                    // if (!arrayEquals(hash, action.hash_before)) {\n                    //     console.error(\"ACTION HASH DOES NOT MATCH\");\n                    // }\n\n                    break;\n                }\n                case WasmActionType.Grow: {\n                    console.log(\"ROLLING BACK GROW!\");\n\n                    await this.assign_memory(new Uint8Array(memory.buffer, 0, action.old_page_count * WASM_PAGE_SIZE));\n                    memory = this.wasm_instance!.instance.exports.memory as WebAssembly.Memory;\n\n                    // let hash = this.hash();\n                    // if (!arrayEquals(hash, action.hash_before)) {\n                    //     console.error(\"GROW ACTION HASH DOES NOT MATCH\");\n                    // }\n\n                    break;\n                }\n                case WasmActionType.GlobalSet: {\n                    (this.wasm_instance?.instance.exports[action.global_id] as WebAssembly.Global).value = action.old_value;\n                    break;\n                }\n            }\n        }\n    }\n\n    steps_remaining(time_to_progress: number): number {\n        return (((this.current_time + time_to_progress) - this.recurring_call_time) / this._recurring_call_interval);\n    }\n\n    async progress_time(time_progressed: number) {\n        // time_progressed is repurposed as a resimulation budget.\n        this.current_time += time_progressed;\n\n        // Add recurring function calls\n        if (this._recurring_call_name && this._recurring_call_interval > 0) {\n            while ((this.current_time - this.recurring_call_time) > this._recurring_call_interval) {\n                this.recurring_call_time += this._recurring_call_interval;\n\n                let time_stamp = {\n                    time: this.recurring_call_time,\n                    player_id: 0\n                };\n\n                this._upcoming_function_calls.push({\n                    function_name: this._recurring_call_name,\n                    time_stamp,\n                    args: []\n                });\n            }\n        }\n\n        this._upcoming_function_calls.sort((a, b) => (time_stamp_compare(a.time_stamp, b.time_stamp)));\n\n        // TODO: Assertion for duplicate time stamps.\n\n        // TODO: Estimate how long a fixed update takes and use that to not spend too much computation.\n        let start_time = performance.now();\n\n        while (this._upcoming_function_calls[0] && Math.sign(this._upcoming_function_calls[0].time_stamp.time - this.current_time) == -1) {\n            let function_call = this._upcoming_function_calls.shift()!;\n\n            //  console.log(\"CALLING %s\", function_call.function_name, function_call.time_stamp);\n\n            await this._call_inner(function_call.function_name, function_call.time_stamp, function_call!.args);\n\n            let time_now = performance.now();\n            if ((start_time - time_now) > (time_progressed * 0.75)) {\n                console.log(\"[tangle] Bailing out of simulation to avoid missed frames\")\n                break;\n            }\n        }\n    }\n\n    private async _apply_snapshot(wasm_snapshot_before: WasmSnapShot) {\n        if (wasm_snapshot_before) {\n            // Apply snapshot\n            this.assign_memory(wasm_snapshot_before.memory);\n\n            let values = Object.values(this.wasm_instance!.instance.exports);\n\n            for (let j = 0; j < wasm_snapshot_before.globals.length; j++) {\n                (values[wasm_snapshot_before.globals[j][0]] as WebAssembly.Global).value = wasm_snapshot_before.globals[j][1];\n            }\n        }\n    }\n\n    private _get_wasm_snapshot(): WasmSnapShot {\n        // This could be optimized by checking ahead of time which globals need to be synced.\n        let globals = new Array();\n        let j = 0;\n        for (const [key, v] of Object.entries(this.wasm_instance!.instance.exports)) {\n            if (key.slice(0, 3) == \"wg_\") {\n                //  console.log(\"SNAP SHOT: \", [j, (v as WebAssembly.Global).value]);\n                globals.push([j, (v as WebAssembly.Global).value]);\n            }\n            j += 1;\n        }\n        return {\n            // This nested Uint8Array constructor creates a deep copy.\n            memory: new Uint8Array(new Uint8Array((this.wasm_instance!.instance.exports.memory as WebAssembly.Memory).buffer)),\n            globals\n        };\n\n    }\n\n    private async _call_inner(function_name: string, time_stamp: TimeStamp, args: number[]): Promise<number> {\n        // If this function does not exist don't bother calling it.\n        if (!this.wasm_instance?.instance.exports[function_name]) {\n            // TODO: Returning 0 isn't correct\n            return 0;\n        }\n\n        // Rewind any function calls that occur after this.\n        let i = this.function_calls.length;\n        let actions_to_remove = 0;\n        for (; i > 0; i--) {\n            // Keep going until a timestamp less than `time_stamp` is found.\n            let function_call = this.function_calls[i - 1];\n            if (time_stamp_compare(function_call.time_stamp, time_stamp) == -1) {\n\n                if (this.function_calls[i]) {\n                    await this._revert_actions(actions_to_remove);\n\n                    // This will only happen if we're using the WasmSnapshot RollbackStrategy.\n                    let wasm_snapshot_before = this.function_calls[i].wasm_snapshot_before;\n                    if (wasm_snapshot_before) {\n                        this._apply_snapshot(wasm_snapshot_before);\n                    }\n                    /*\n                    let hash_after_revert = this.hash();\n\n                    if (!arrayEquals(hash_after_revert, this.function_calls[i].hash_before)) {\n                        console.error(\"HASHES DO NOT MATCH DURING REVERT\");\n                    }\n                    */\n                }\n                break;\n            }\n            actions_to_remove += function_call.actions_caused;\n        }\n\n        let before = this._actions.length;\n\n        let function_call = this.wasm_instance?.instance.exports[function_name] as CallableFunction;\n        if (function_call) {\n            let wasm_snapshot_before;\n            if (this._rollback_strategy == RollbackStrategy.WasmSnapshots) {\n                wasm_snapshot_before = this._get_wasm_snapshot();\n            }\n\n            function_call(...args);\n\n            let after = this._actions.length;\n\n            if (after - before > 0 || this._rollback_strategy == RollbackStrategy.WasmSnapshots) {\n                let hash_after;\n\n                if (this.hash_tracking) {\n                    hash_after = this.hash();\n                }\n\n                this.function_calls.splice(i, 0, {\n                    name: function_name,\n                    args: args,\n                    time_stamp: time_stamp,\n                    actions_caused: after - before,\n                    wasm_snapshot_before,\n                    hash_after\n                });\n            }\n        }\n\n        // Replay any function calls that occur after this function\n        for (let j = i + 1; j < this.function_calls.length; j++) {\n            let f = this.function_calls[j];\n            // Note: It is assumed function calls cannot be inserted with an out-of-order offset by the same peer.\n            // If that were true the offset would need to be checked and potentially updated here.\n\n            let wasm_snapshot_before;\n            if (this._rollback_strategy == RollbackStrategy.WasmSnapshots) {\n                wasm_snapshot_before = this._get_wasm_snapshot();\n            }\n\n            let before = this._actions.length;\n            (this.wasm_instance?.instance.exports[f.name] as CallableFunction)(...f.args);\n\n            if (this.hash_tracking) {\n                f.hash_after = this.hash();\n            }\n\n            let after = this._actions.length;\n            f.actions_caused = after - before;\n            f.wasm_snapshot_before = wasm_snapshot_before;\n        }\n        return i;\n    }\n\n    /// Returns the function call of this instance.\n    async call_with_time_stamp(time_stamp: TimeStamp, function_name: string, args: Array<number>) {\n        // TODO: Check for a PlayerId to insert into args\n        // TODO: Use a real player ID.\n\n        this._upcoming_function_calls.push({\n            function_name,\n            args,\n            time_stamp\n        });\n\n        /*\n        let new_call_index = await this._call_inner(function_name, time_stamp, args);\n\n        // console.log(\"FUNCTION CALLS: \", structuredClone(this.function_calls));\n        this.time_offset += 1;\n        return new_call_index;\n        */\n    }\n\n    /// Call a function but ensure its results do not persist and cannot cause a desync.\n    /// This can be used for things like drawing or querying from the Wasm\n    async call_and_revert(function_name: string, args: Array<number>) {\n        let before = this._actions.length;\n        let snapshot;\n        if (this._rollback_strategy == RollbackStrategy.WasmSnapshots) {\n            snapshot = this._get_wasm_snapshot();\n        }\n        (this.wasm_instance?.instance.exports[function_name] as CallableFunction)(...args);\n        if (snapshot) {\n            this._apply_snapshot(snapshot);\n        }\n        let after = this._actions.length;\n        await this._revert_actions(after - before);\n    }\n\n    // TODO: These are just helpers and aren't that related to the rest of the code in this:\n    gzip_encode(data_to_compress: Uint8Array) {\n        let memory = OfflineTangle._tangle_wasm?.instance.exports.memory as WebAssembly.Memory;\n        let exports = OfflineTangle._tangle_wasm!.instance.exports;\n\n        let pointer = (exports.reserve_space as CallableFunction)(data_to_compress.byteLength);\n        const destination = new Uint8Array(memory.buffer, pointer, data_to_compress.byteLength);\n        destination.set(new Uint8Array(data_to_compress));\n\n        (exports.gzip_encode as CallableFunction)();\n        let result_pointer = new Uint32Array(memory.buffer, pointer, 2);\n        let result_data = new Uint8Array(memory.buffer, result_pointer[0], result_pointer[1]);\n        console.log(\"COMPRESSED LENGTH: \", result_data.byteLength);\n        console.log(\"COMPRESSION RATIO: \", data_to_compress.byteLength / result_data.byteLength);\n        return result_data;\n    }\n\n    gzip_decode(data_to_decode: Uint8Array) {\n        let memory = OfflineTangle._tangle_wasm?.instance.exports.memory as WebAssembly.Memory;\n        let instance = OfflineTangle._tangle_wasm!.instance.exports;\n\n        let pointer = (instance.reserve_space as CallableFunction)(data_to_decode.byteLength);\n        const destination = new Uint8Array(memory.buffer, pointer, data_to_decode.byteLength);\n        destination.set(data_to_decode);\n\n        (instance.gzip_decode as CallableFunction)();\n        let result_pointer = new Uint32Array(memory.buffer, pointer, 2);\n        let result_data = new Uint8Array(memory.buffer, result_pointer[0], result_pointer[1]);\n        return new Uint8Array(result_data);\n    }\n    hash(): Uint8Array {\n        let data_to_hash = new Uint8Array((this.wasm_instance!.instance.exports.memory as WebAssembly.Memory).buffer);\n        return this.hash_data(data_to_hash);\n    }\n    /*\n    print_globals() {\n        for (const [key, v] of Object.entries(this.wasm_instance!.instance.exports)) {\n            if (key.slice(0, 3) == \"wg_\") {\n                console.log(\"GLOBAL: \", [key, v.value]);\n            }\n        }\n    }\n    */\n    hash_data(data_to_hash: Uint8Array): Uint8Array {\n        let memory = OfflineTangle._tangle_wasm?.instance.exports.memory as WebAssembly.Memory;\n        let instance = OfflineTangle._tangle_wasm!.instance.exports;\n\n        let pointer = (instance.reserve_space as CallableFunction)(data_to_hash.byteLength);\n        const destination = new Uint8Array(memory.buffer, pointer, data_to_hash.byteLength);\n        destination.set(new Uint8Array(data_to_hash));\n\n        (instance.xxh3_128_bit_hash as CallableFunction)();\n        let hashed_result = new Uint8Array(new Uint8Array(memory.buffer, pointer, 16));\n        return hashed_result;\n    }\n}\n/// Preprocess the binary to record all persistent state edits.\nasync function process_binary(wasm_binary: Uint8Array, export_globals: boolean, track_changes: boolean) {\n    if (!(export_globals || track_changes)) {\n        return wasm_binary;\n    }\n\n    let length = wasm_binary.byteLength;\n    let pointer = (OfflineTangle._tangle_wasm?.instance.exports.reserve_space as CallableFunction)(length);\n\n    let memory = OfflineTangle._tangle_wasm?.instance.exports.memory as WebAssembly.Memory;\n\n    const data_location = new Uint8Array(memory.buffer, pointer, length);\n    data_location.set(new Uint8Array(wasm_binary));\n    (OfflineTangle._tangle_wasm?.instance.exports.prepare_wasm as CallableFunction)(export_globals, track_changes);\n\n    // TODO: Write these to an output buffer instead of having two calls for them.\n    let output_ptr = (OfflineTangle._tangle_wasm?.instance.exports.get_output_ptr as CallableFunction)();\n    let output_len = (OfflineTangle._tangle_wasm?.instance.exports.get_output_len as CallableFunction)();\n    const output_wasm = new Uint8Array(memory.buffer, output_ptr, output_len);\n    return output_wasm;\n}\n\n\nexport function arrayEquals(a: Uint8Array, b: Uint8Array) {\n    if (a.length != b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "let text_encoder = new TextEncoder();\nlet text_decoder = new TextDecoder();\n\nexport class MessageWriterReader {\n    output: Uint8Array;\n    data_view: DataView;\n    offset: number = 0;\n\n    constructor(output: Uint8Array) {\n        this.output = output;\n        this.data_view = new DataView(output.buffer, output.byteOffset);\n    }\n\n    get_result_array() {\n        return this.output.subarray(0, this.offset);\n    }\n\n    write_raw_bytes(bytes: Uint8Array) {\n        this.output.subarray(this.offset).set(bytes);\n        this.offset += bytes.length;\n    }\n\n    read_remaining_raw_bytes() {\n        return this.output.subarray(this.offset);\n    }\n\n    read_fixed_raw_bytes(length: number) {\n        let result = this.output.slice(this.offset, this.offset + length);\n        this.offset += length;\n        return result;\n    }\n\n    write_string(string: string) {\n        let length = text_encoder.encodeInto(string, this.output.subarray(this.offset + 4)).written!;\n        this.data_view.setUint32(this.offset, length);\n        this.offset += length + 4;\n    }\n\n    read_string(): string {\n        let length = this.read_u32();\n        let result = text_decoder.decode(this.output.subarray(this.offset, this.offset + length));\n        this.offset += length;\n        return result;\n    }\n\n    write_u8(v: number) {\n        this.data_view.setUint8(this.offset, v);\n        this.offset += 1;\n    }\n\n    write_u16(v: number) {\n        this.data_view.setUint16(this.offset, v);\n        this.offset += 2;\n    }\n\n    write_u32(v: number) {\n        this.data_view.setUint32(this.offset, v);\n        this.offset += 4;\n    }\n\n    write_f32(v: number) {\n        this.data_view.setFloat32(this.offset, v);\n        this.offset += 4;\n    }\n\n    read_u8() {\n        let result = this.data_view.getUint8(this.offset);\n        this.offset += 1;\n        return result;\n    }\n\n    read_u16() {\n        let result = this.data_view.getUint16(this.offset);\n        this.offset += 2;\n        return result;\n    }\n\n    read_u32() {\n        let result = this.data_view.getUint32(this.offset);\n        this.offset += 4;\n        return result;\n    }\n\n    read_f32() {\n        let result = this.data_view.getFloat32(this.offset);\n        this.offset += 4;\n        return result;\n    }\n\n    read_f64() {\n        let result = this.data_view.getFloat64(this.offset);\n        this.offset += 8;\n        return result;\n    }\n\n    write_f64(v: number) {\n        this.data_view.setFloat64(this.offset, v);\n        this.offset += 8;\n    }\n\n    read_i64() {\n        let result = this.data_view.getBigInt64(this.offset);\n        this.offset += 8;\n        return result;\n    }\n\n    write_i64(v: bigint) {\n        this.data_view.setBigInt64(this.offset, v);\n        this.offset += 8;\n    }\n\n    write_tagged_number(number: number | bigint) {\n        if (typeof number == \"bigint\") {\n            this.write_u8(NumberTag.I64);\n            this.write_i64(number);\n        } else {\n            this.write_u8(NumberTag.F64);\n            this.write_f64(number);\n        }\n    }\n\n    read_tagged_number() {\n        let tag_byte = this.read_u8();\n        if (tag_byte === NumberTag.F64) {\n            return this.read_f64();\n        } else {\n            return this.read_i64();\n        }\n    }\n}\n\nenum NumberTag {\n    F64,\n    I64,\n}\n", "import { PeerId, Room, RoomState } from \"./room.js\";\nimport { arrayEquals, OfflineTangle, TimeStamp, time_stamp_compare } from \"./offline_tangle.js\";\nimport { MessageWriterReader } from \"./message_encoding.js\";\n\nexport { RoomState, PeerId } from \"./room.js\";\n\ntype FunctionCallMessage = {\n    function_name: string,\n    time_stamp: TimeStamp\n    args: Array<number>\n}\n\nenum MessageType {\n    WasmCall,\n    RequestHeap,\n    SentHeap,\n    TimeProgressed,\n    SetProgram,\n    DebugShareHistory,\n    // Used to figure out roundtrip time.\n    BounceBack,\n    BounceBackReturn\n}\n\ntype PeerData = {\n    last_sent_message: number,\n    last_received_message: number,\n    round_trip_time: number,\n}\n\nlet text_encoder = new TextEncoder();\nlet text_decoder = new TextDecoder();\n\nenum TangleState {\n    Disconnected,\n    Connected,\n    RequestingHeap\n}\n\nclass UserIdType { }\nexport const UserId = new UserIdType();\n\nexport class Tangle {\n    room!: Room;\n    private _tangle!: OfflineTangle;\n    private _buffered_messages: Array<FunctionCallMessage> = [];\n    private _peer_data: Map<PeerId, PeerData> = new Map();\n    private outgoing_message_buffer = new Uint8Array(500);\n    private _tangle_state = TangleState.Disconnected;\n    private _current_program_binary = new Uint8Array();\n    private _block_reentrancy = false;\n    private _enqueued_inner_calls = new Array(Function());\n    private _debug_enabled = true;\n\n    private async _run_inner_function(f: Function, enqueue_condition: boolean = false) {\n        if (!this._block_reentrancy && !enqueue_condition) {\n            this._block_reentrancy = true;\n            await f();\n            let f1 = this._enqueued_inner_calls.shift();\n            while (f1) {\n                await f1();\n                f1 = this._enqueued_inner_calls.shift();\n            }\n            this._block_reentrancy = false;\n        } else {\n            this._enqueued_inner_calls.push(f);\n        }\n    }\n\n    static async setup(wasm_binary: Uint8Array, wasm_imports: WebAssembly.Imports, recurring_call_interval: number, on_state_change_callback?: (state: TangleState, tangle: Tangle) => void): Promise<Tangle> {\n        let tangle = new Tangle();\n        await tangle.setup_inner(wasm_binary, wasm_imports, recurring_call_interval, on_state_change_callback);\n        return tangle;\n    }\n\n    private request_heap() {\n        // Ask an arbitrary peer for the heap\n        let lowest_latency_peer = this.room.get_lowest_latency_peer();\n        if (lowest_latency_peer) {\n            this.room.send_message(this._encode_bounce_back_message(), lowest_latency_peer);\n            this.room.send_message(this._encode_request_heap_message(), lowest_latency_peer);\n        }\n    }\n\n    /// This actually encodes globals as well, not just the heap.\n    private _encode_heap_message(): Uint8Array {\n        // TODO: Send all function calls and events here.\n\n        console.log(\"WASM MODULE SENDING: \", this._tangle.wasm_instance!.instance.exports);\n        let memory = this._tangle.wasm_instance!.instance.exports.memory as WebAssembly.Memory;\n        let encoded_data = this._tangle.gzip_encode(new Uint8Array(memory.buffer));\n\n        let exports = this._tangle.wasm_instance!.instance.exports;\n        let globals_count = 0;\n        for (const [key, v] of Object.entries(exports)) {\n            if (key.slice(0, 3) == \"wg_\") {\n                globals_count += 1;\n            }\n        }\n        let heap_message = new Uint8Array(encoded_data.byteLength + 1 + 8 + 8 + 4 + (8 + 4 + 1) * globals_count);\n        let message_writer = new MessageWriterReader(heap_message);\n        message_writer.write_u8(MessageType.SentHeap);\n        message_writer.write_f64(this._tangle.current_time);\n        message_writer.write_f64(this._tangle.recurring_call_time);\n        console.log(\"ENCODING RECURRING CALL TIME: \", this._tangle.recurring_call_time);\n\n        // Encode all mutable globals\n        message_writer.write_u16(globals_count);\n        for (const [key, v] of Object.entries(exports)) {\n            if (key.slice(0, 3) == \"wg_\") {\n                let index = parseInt(key.match(/\\d+$/)![0]);\n                message_writer.write_u32(index);\n                message_writer.write_tagged_number((v as WebAssembly.Global).value);\n            }\n        }\n        message_writer.write_raw_bytes(encoded_data);\n\n        return heap_message;\n    }\n\n    private _decode_heap_message(data: Uint8Array) {\n        let message_reader = new MessageWriterReader(data);\n\n        let current_time = message_reader.read_f64();\n        let recurring_call_time = message_reader.read_f64();\n        let mutable_globals_length = message_reader.read_u16();\n\n        let global_values = new Map();\n        for (let i = 0; i < mutable_globals_length; i++) {\n            let index = message_reader.read_u32();\n            let value = message_reader.read_tagged_number();\n            global_values.set(index, value);\n        }\n\n        // TODO: When implemented all function calls and events need to be decoded here.\n        let heap_data = this._tangle.gzip_decode(message_reader.read_remaining_raw_bytes());\n\n        return {\n            current_time,\n            recurring_call_time,\n            heap_data,\n            global_values\n        };\n    }\n\n\n    private _encode_new_program_message(program_data: Uint8Array): Uint8Array {\n        let encoded_data = this._tangle.gzip_encode(program_data);\n\n        let message = new Uint8Array(encoded_data.byteLength + 1);\n        let message_writer = new MessageWriterReader(message);\n        message_writer.write_u8(MessageType.SetProgram);\n        message_writer.write_raw_bytes(encoded_data);\n\n        return message;\n    }\n\n    private _decode_new_program_message(data_in: Uint8Array) {\n        let data = this._tangle.gzip_decode(data_in);\n        return data;\n    }\n\n    private _encode_wasm_call_message(function_string: string, time: number, args: Array<number>, hash?: Uint8Array): Uint8Array {\n        let message_writer = new MessageWriterReader(this.outgoing_message_buffer);\n        message_writer.write_u8(MessageType.WasmCall);\n\n        message_writer.write_f64(time);\n        message_writer.write_u8(args.length);\n\n\n        // Encode args. \n        // TODO: For now all args are encoded as f64s, but that is incorrect.\n        for (let i = 0; i < args.length; i++) {\n            message_writer.write_f64(args[i]);\n        }\n\n        /*\n        if (this._debug_enabled) {\n            message_writer.write_raw_bytes(hash!);\n        }\n        */\n\n        // TODO: The set of possible function call names is finite per-module, so this could be\n        // turned into a simple index instead of sending the whole string.\n        let text_length = text_encoder.encodeInto(function_string, this.outgoing_message_buffer.subarray(message_writer.offset)).written!;\n        return this.outgoing_message_buffer.subarray(0, message_writer.offset + text_length);\n    }\n\n    private _decode_wasm_call_message(data: Uint8Array) {\n        let message_reader = new MessageWriterReader(data);\n\n        let time = message_reader.read_f64();\n        let args_length = message_reader.read_u8();\n\n        let args = new Array<number>(args_length);\n        for (let i = 0; i < args.length; i++) {\n            args[i] = message_reader.read_f64();\n        }\n\n        let hash;\n\n        /*\n        let hash;\n        if (this._debug_enabled) {\n            hash = message_reader.read_fixed_raw_bytes(16);\n        }\n        */\n\n        let function_name = text_decoder.decode(data.subarray(message_reader.offset));\n        return {\n            function_name,\n            time,\n            args,\n            hash\n        };\n    }\n\n    private _encode_time_progressed_message(time_progressed: number): Uint8Array {\n        let message_writer = new MessageWriterReader(this.outgoing_message_buffer);\n        message_writer.write_u8(MessageType.TimeProgressed);\n        message_writer.write_f64(time_progressed);\n        return message_writer.get_result_array();\n    }\n\n    private _decode_time_progressed_message(data: Uint8Array) {\n        return new DataView(data.buffer, data.byteOffset).getFloat64(0);\n    }\n\n    private _encode_request_heap_message(): Uint8Array {\n        this.outgoing_message_buffer[0] = MessageType.RequestHeap;\n        return this.outgoing_message_buffer.subarray(0, 1);\n    }\n\n    private _encode_bounce_back_message(): Uint8Array {\n        let writer = new MessageWriterReader(this.outgoing_message_buffer);\n        writer.write_u8(MessageType.BounceBack);\n        writer.write_f64(Date.now());\n        return writer.get_result_array();\n    }\n\n    private _decode_bounce_back_return(data: Uint8Array): number {\n        let reader = new MessageWriterReader(data);\n        return reader.read_f64();\n    }\n\n    private _encode_share_history(): Uint8Array {\n        // TODO: Don't use a fixed size buffer and instead resize if necessary.\n        let data = new Uint8Array(50_000);\n\n        let message_writer = new MessageWriterReader(data);\n        message_writer.write_u8(MessageType.DebugShareHistory);\n\n        let history_length = this._tangle.function_calls.length;\n\n        for (let i = 0; i < history_length; i++) {\n\n            let function_call = this._tangle.function_calls[i];\n            message_writer.write_f64(function_call.time_stamp.time);\n            message_writer.write_raw_bytes(function_call.hash_after!);\n\n            message_writer.write_string(function_call.name);\n        }\n\n        return message_writer.get_result_array();\n    }\n\n    private _decode_share_history(data: Uint8Array) {\n        let history = [];\n\n        let message_reader = new MessageWriterReader(data);\n\n        while (message_reader.offset < data.length) {\n            let time = message_reader.read_f64();\n            let hash = message_reader.read_fixed_raw_bytes(16);\n            let function_name = message_reader.read_string();\n\n            history.push({\n                time,\n                hash,\n                function_name\n            });\n        }\n        return history;\n    }\n\n    private async setup_inner(wasm_binary: Uint8Array, wasm_imports: WebAssembly.Imports, recurring_call_interval: number, on_state_change_callback?: (state: TangleState, tangle: Tangle) => void) {\n        let room_configuration = {\n            on_peer_joined: (peer_id: PeerId) => {\n                this._run_inner_function(async () => {\n                    this._peer_data.set(peer_id, {\n                        last_sent_message: 0,\n                        last_received_message: Number.MAX_VALUE,\n                        round_trip_time: 0,\n                    });\n                    this.room.send_message(this._encode_bounce_back_message(), peer_id);\n                });\n            },\n            on_peer_left: (peer_id: PeerId, time: number) => {\n                this._run_inner_function(async () => {\n                    console.log(\"REMOVE PEER HERE\");\n                    this._peer_data.delete(peer_id);\n\n                    // TODO: This is not a good way to synchronize when a peer disconnects.\n                    // It will likely work in some cases but it could also easily desync.\n\n                    time = ((this._tangle.current_time + 1000) % 500) + this._tangle.current_time;\n                    if (time < this.earliest_safe_memory_time()) {\n                        console.error(\"POTENTIAL DESYNC DUE TO PEER LEAVING!\");\n                    }\n\n                    let time_stamp = {\n                        time,\n                        player_id: 0 // 0 is for events sent by the server.\n                    };\n\n                    console.log(\"CALLING PEER LEFT\");\n                    this._tangle.call_with_time_stamp(time_stamp, \"peer_left\", [peer_id]);\n                });\n            },\n            on_state_change: (state: RoomState) => {\n                this._run_inner_function(async () => {\n                    // TODO: Change this callback to have room passed in.\n\n                    console.log(\"[tangle] Room state changed: \", RoomState[state]);\n\n                    switch (state) {\n                        case RoomState.Connected: {\n                            this.request_heap();\n\n                            if (this._peer_data.size == 0) {\n                                // We have no peer so we're connected\n                                this._tangle_state = TangleState.Connected;\n                                on_state_change_callback?.(this._tangle_state, this);\n                            }\n                            break;\n                        }\n                        case RoomState.Disconnected: {\n                            this._tangle_state = TangleState.Disconnected;\n                            on_state_change_callback?.(this._tangle_state, this);\n                            break;\n                        }\n                        case RoomState.Joining: {\n                            this._tangle_state = TangleState.Disconnected;\n                            on_state_change_callback?.(this._tangle_state, this);\n                            break;\n                        }\n                    }\n\n                });\n            },\n            on_message: async (peer_id: PeerId, message: Uint8Array) => {\n                let peer_connected_already = this._peer_data.get(peer_id);\n\n                this._run_inner_function(async () => {\n                    // Ignore messages from peers that have disconnected. \n                    // TODO: Evaluate if this could cause desyncs.\n\n                    if (!this._peer_data.get(peer_id!)) {\n                        return;\n                    }\n\n                    let message_type = message[0];\n                    let message_data = message.subarray(1);\n\n                    switch (message_type) {\n                        case (MessageType.TimeProgressed): {\n                            let time = this._decode_time_progressed_message(message_data);\n                            this._peer_data.get(peer_id)!.last_received_message = time;\n                            break;\n                        }\n                        case (MessageType.WasmCall): {\n                            let m = this._decode_wasm_call_message(message_data);\n                            this._peer_data.get(peer_id)!.last_received_message = m.time;\n\n                            let time_stamp = {\n                                time: m.time,\n                                player_id: peer_id\n                            };\n\n                            if (this._tangle_state == TangleState.RequestingHeap) {\n                                this._buffered_messages.push({\n                                    function_name: m.function_name,\n                                    time_stamp: time_stamp,\n                                    args: m.args\n                                });\n                            } else {\n                                await this._tangle.call_with_time_stamp(time_stamp, m.function_name, m.args);\n                            }\n\n                            break;\n                        }\n                        case (MessageType.RequestHeap): {\n                            // Also send the program binary.\n                            let program_message = this._encode_new_program_message(this._current_program_binary);\n                            this.room.send_message(program_message);\n\n                            let heap_message = this._encode_heap_message();\n                            this.room.send_message(heap_message);\n                            break;\n                        }\n                        case (MessageType.SentHeap): {\n                            console.log(\"[tangle] Setting heap\");\n                            let heap_message = this._decode_heap_message(message_data);\n\n                            // TODO: Get roundtrip time to peer and increase current_time by half of that.\n                            let round_trip_time = this._peer_data.get(peer_id)!.round_trip_time;\n                            console.log(\"[tangle] Approximate round trip offset: \", round_trip_time / 2);\n\n                            let current_time = heap_message.current_time;\n\n                            console.log(\"INITIAL RECURRING CALL TIME: \", heap_message.recurring_call_time);\n                            await this._tangle.reset_with_wasm_memory(\n                                heap_message.heap_data,\n                                heap_message.global_values,\n                                current_time + (round_trip_time / 2),\n                                heap_message.recurring_call_time,\n                            );\n\n                            for (let m of this._buffered_messages) {\n                                await this._tangle.call_with_time_stamp(m.time_stamp, m.function_name, m.args);\n                            }\n                            this._buffered_messages = [];\n\n                            this._tangle_state = TangleState.Connected;\n                            on_state_change_callback?.(this._tangle_state, this);\n                            break;\n                        }\n                        case (MessageType.SetProgram): {\n                            // TODO: This is incorrect. Make sure all peers are aware of their roundtrip average with each-other\n                            let round_trip_time = this._peer_data.get(peer_id)!.round_trip_time;\n                            console.log(\"[tangle] Approximate round trip offset: \", round_trip_time / 2);\n\n                            console.log(\"SETTING PROGRAM!\");\n                            let new_program = this._decode_new_program_message(message_data);\n                            this._current_program_binary = new_program;\n                            await this._tangle.reset_with_new_program(new_program, (round_trip_time / 2));\n                            console.log(\"DONE SETTING PROGRAM\");\n                            break;\n                        }\n                        case (MessageType.DebugShareHistory): {\n                            let remote_history = this._decode_share_history(message_data);\n                            console.log(\"RECEIVED SHARED HISTORY DUE TO DESYNC\");\n                            console.log(\"SHARED HISTORY: \", this._decode_share_history(message_data));\n\n                            let i = 0;\n                            let j = 0;\n                            while (i < this._tangle.function_calls.length && j < remote_history.length) {\n                                let f0 = this._tangle.function_calls[i];\n                                let f1 = remote_history[j];\n\n                                let time_stamp1 = {\n                                    time: f1.time,\n                                    player_id: peer_id\n                                };\n\n                                let comparison = time_stamp_compare(f0.time_stamp, time_stamp1);\n                                switch (comparison) {\n                                    case -1: {\n                                        i += 1;\n                                        break;\n                                    }\n                                    case 1: {\n                                        j += 1;\n                                        break;\n                                    }\n                                    case 0: {\n                                        // They are equal. Compare properties:\n                                        if (!arrayEquals(f0.hash_after!, f1.hash)) {\n                                            console.log('DESYNC. LOCAL INDEX: %d REMOTE INDEX: %d', i, j);\n                                        }\n                                        i += 1;\n                                        j += 1;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                        case (MessageType.BounceBack): {\n                            message[0] = MessageType.BounceBackReturn;\n                            this.room.send_message(message, peer_id);\n                            break;\n                        }\n                        case (MessageType.BounceBackReturn): {\n                            let time = this._decode_bounce_back_return(message_data);\n                            this._peer_data.get(peer_id)!.round_trip_time = Date.now() - time;\n                            break;\n                        }\n                    }\n                }, !peer_connected_already);\n            }\n        };\n        this._tangle = await OfflineTangle.setup(wasm_binary, wasm_imports, recurring_call_interval);\n        this.room = await Room.setup(room_configuration);\n        this._current_program_binary = wasm_binary;\n    }\n\n    set_program(new_program: Uint8Array) {\n        this._run_inner_function(async () => {\n            //   if (!arrayEquals(new_program, this._current_program_binary)) {\n            await this._tangle.reset_with_new_program(\n                new_program,\n                0\n            );\n            this._current_program_binary = new_program;\n\n            console.log(\"SENDING NEW PROGRAM MESSAGE!\");\n            this.room.send_message(this._encode_new_program_message(new_program));\n            // }\n        });\n    }\n\n    private _process_args(args: Array<number | UserIdType>): Array<number> {\n        return args.map((a) => {\n            if (typeof a != \"number\") {\n                // Assume this is a UserId\n                return this.room.my_id;\n            } else {\n                return a;\n            }\n        });\n    }\n\n    call(function_name: string, args: [number | UserIdType]) {\n        this._run_inner_function(async () => {\n\n            // TODO: Only process the args like this for local calls.\n            // Let remote calls insert the ID themselves\n            // As-is this design makes it trivial for peers to spoof each-other.\n            let args_processed = this._process_args(args);\n\n            // TODO: Ensure each message has a unique timestamp.\n            let time_stamp = {\n                time: this._tangle.current_time,\n                player_id: this.room.my_id\n            };\n\n            // Adding time delay here decreases responsivity but also decreases the likelihood\n            // peers will have to rollback.\n            // This could be a good place to add delay if a peer has higher latency than \n            // everyone else in the room.\n            // time_stamp.time += 50;\n\n            await this._tangle.call_with_time_stamp(time_stamp, function_name, args_processed);\n\n            // Network the call\n            this.room.send_message(this._encode_wasm_call_message(function_name, time_stamp.time, args_processed));\n\n            for (let [_, value] of this._peer_data) {\n                value.last_sent_message = Math.max(value.last_received_message, time_stamp.time);\n            }\n        });\n    }\n\n    /// This call will have no impact but can be useful to draw or query from the world.\n    call_and_revert(function_name: string, args: Array<number>) {\n        this._run_inner_function(async () => {\n            let args_processed = this._process_args(args);\n            this._tangle.call_and_revert(function_name, args_processed);\n        });\n    }\n\n    /// Resync with the room, immediately catching up.\n    resync() {\n        // TODO: Check for reentrancy\n        console.log(\"REQUESTING HEAP!\");\n        this.request_heap();\n    }\n\n    private earliest_safe_memory_time(): number {\n        let earliest_safe_memory = this._tangle.recurring_call_time;\n        for (let [_, value] of this._peer_data) {\n            earliest_safe_memory = Math.min(earliest_safe_memory, value.last_received_message);\n        }\n        return earliest_safe_memory;\n    }\n\n    private async _progress_time_inner(time_progressed: number) {\n        // TODO: Detect if we're falling behind and can't keep up.\n\n        await this._tangle.progress_time(time_progressed);\n\n        // Keep track of when a message was received from each peer\n        // and use that to determine what history is safe to throw away.\n        let earliest_safe_memory = this._tangle.recurring_call_time;\n        for (let [peer_id, value] of this._peer_data) {\n            earliest_safe_memory = Math.min(earliest_safe_memory, value.last_received_message);\n\n            // If we haven't messaged our peers in a while send them a message\n            // This lets them know nothing has happened and they can clear memory.\n            // I suspect the underlying RTCDataChannel protocol is sending keep alives as well,\n            // it'd be better to figure out if those could be used instead.\n            const KEEP_ALIVE_THRESHOLD = 200;\n            if ((this._tangle.current_time - value.last_sent_message) > KEEP_ALIVE_THRESHOLD) {\n                this.room.send_message(this._encode_time_progressed_message(this._tangle.current_time), peer_id);\n            }\n        }\n\n        // This -100 is for debugging purposes only\n        this._tangle.remove_history_before(earliest_safe_memory - 100);\n\n    }\n    progress_time(time_progressed: number) {\n        this._run_inner_function(async () => {\n            await this._progress_time_inner(time_progressed);\n        });\n    }\n    get_memory(): WebAssembly.Memory {\n        return this._tangle.wasm_instance?.instance.exports.memory as WebAssembly.Memory;\n    }\n}\n\n"],
  "mappings": "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",
  "names": ["RoomState", "data_channel", "length", "data", "length", "location", "function_call", "before", "length", "NumberTag", "text_encoder", "text_decoder", "text_encoder", "text_decoder"]
}
